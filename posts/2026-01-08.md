---
title: '팝팡이 화면 성능을 개선하기 위해 선택한 방법'
date: '2026-01-08'
category: 'iOS'
excerpt: '팝팡 iOS'
cover: '/images/logo.png'
---

안녕하세요 팝팡 iOS 개발자 김동현입니다.

> PopPang 서비스에서 특정 화면에서 메모리가 상승하는 문제가 있었습니다.
> 처음에는 데이터 양의 문제라고 생각했지만, 실제 원인은 전혀 다른 곳에 있었습니다.
> 이 글에서는 문제를 어떻게 정의했고, 어떤 기준으로 해결했는지를 공유합니다.

<br/>

<img
  src="https://github.com/user-attachments/assets/3938e583-0fc4-4620-99b0-bf761e60a1ba"
  width="400"
/>

## 고민했던 문제

SwiftUI를 사용하면 이런 경험을 한번 쯤 하게 됩니다.

- List 스크롤할 때 왜 버벅거리지?
- **특정 셀의 상태만 변경되도 왜 전체 화면이 다시 그려지지?**
- ForEach에서 id: \.self를 쓰면 안된다는데 정확히 이유가 뭐지?
- 에어비엔비는 15% 성능 개선을 어떻게 했을까?
  <br/><br/>

## SwiftUI가 화면을 그리는 기본 메커니즘

SwiftUI는 선언형 UI 프레임워크로, 상태가 변경될 때마다 새로운 뷰 트리를 생성하고  
이전 뷰 트리와 **두 단계로 비교(diffing)** 하여 필요한 부분만 실제 UI에 반영합니다.

```bash
# 상태 변경 시 SwiftUI 내부 동작
1. @State, @ObservableObject 등의 변경 감지
2. 영향받는 뷰의 body 재실행 -> 새로운 View 트리 생성
3. 1차 diffing: Identity diffing
   - 구조, 타입, 명시적 id를 기준으로
   - 이전 View 트리와 새 View 트리를 매칭 (reconciliation)
4. 2차 diffing: Update / Render diffing
   - 같은 View에 대해 stored property 변경 여부 비교
   - Equatable이 있으면 == 사용
   - 없으면 내부(리플렉션 유사) 비교 로직 사용
5. 변경된 View만 body를 다시 실행하고 실제 UI 업데이트
```

<br/><br/>

## 1단계: Identity Diffing

**판단:** 이 View는 이전 프레임의 어떤 View와 같은 존재인가?

**판단기준**

- View 트리 구조(위치)
- 타입(Text, Image, CustomView 등)
- 명시적 id(.id, ForEach(id: ))

```swift
struct UserView: View {
    let name: String
    let age: Int

    var body: some View {
        VStack {
            Text(name)     // 타입이 Text로 고정
            Text("\(age)") // 컴파일 타임에 구조 확정
        }
    }
}

// 같은 타입 구조라면 빠른 비교 가능
// 다른 타입이라면 즉시 재생성 필요함을 인지
```

## 만약 1단계에서 Text("Kim") -> Text("Lee")로 변경된다면

- 타입: Text
- 위치: 동일
- 구조: 동일
  -> 같은 identity로 매칭됨
  -> View는 재생성되지 않고 update 후보가 됩니다.

<br/><br/>

## 2단계: 리플렉션 기반 Property 비교

SwiftUI는 1단계에서 같은 identity로 매칭된 View에 대해 저장 프로퍼티 변경 여부를 판단하기 위해  
**리플렉션에 가까운 내부 비교 로직**을 사용한다고 알려져 있습니다.

**판단:** 같은 View라면 body를 다시 호출해야 하는가?  
**판단 기준:** View의 stored property 값 변경 여부

```swift
// SwiftUI 내부 diffing 로직 (의사코드)
func shouldUpdateView<V: View>(_ oldView: V, _ newView: V) -> Bool {
    // 1. Equatable 타입이면 == 연산자 사용
    if V.self is Equatable.Type {
        return oldView != newView
    }

    // 2. 값 타입(struct)이면 재귀적으로 프로퍼티 비교
    if V.self is ValueType {
        return compareProperties(oldView, newView)
    }

    // 3. 참조 타입(class)이면 참조 동일성 비교
    if V.self is ReferenceType {
        return oldView !== newView
    }

    // 4. 클로저는 비교 불가능 - 항상 다르다고 가정
    if containsClosures(V.self) {
        return true
    }
}
```

## 2단계 예시(Equatable 없음)

```swift
struct UserView: View {
    let name: String    // 이전 name과 동일한가
    let age: Int        // 이전 age 동일한가
}
```

- SwiftUI는 이전 UserView와 현재 UserView를 비교하여 name, age 값이 바뀌었는지 판단합니다.
- 속성이 변경되었다면 body를 재실행합니다.
- Equatable을 채택하지 않으면 저장 프로퍼티들을 재귀적으로 전부 비교하기 때문에 원하지 않는 body 호출이 빈번히 발생할 수 있습니다.

## 2단계 예시(Equatable 있음)

```swift
struct UserView: View, Equatable {
    let name: String    // 이전 name과 동일한가
    let age: Int        // 비교 대상에서 제외

    static func == (lhs: Self, rhs: Self) -> Bool {
        lhs.name == rhs.name
    }
}
```

- Equtable을 채택한다면 == 결과만 사용하여 body 실행 조건을 커스텀할 수 있습니다.
- 덕분에 같은 View에 대해 body재실행 여부를 제어하여 최적화를 할 수 있습니다.

<!--
## 테스트

### 테스트

```swift
import SwiftUI

print("hello world")
print("hello world")
print("hello world")
``` -->

## Reference

- [https://green1229.tistory.com/589](https://green1229.tistory.com/589)
- [https://declan.tistory.com/89](https://declan.tistory.com/89)
